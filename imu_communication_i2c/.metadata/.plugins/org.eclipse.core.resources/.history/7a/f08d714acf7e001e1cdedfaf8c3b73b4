/*
 * imu_uart.h
 *
 *  Created on: 2023/11/09
 *      Author: space
 */

#ifndef IMU_UART_H_
#define IMU_UART_H_

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include "system.h"
#include <string.h>
#include "altera_avalon_pio_regs.h"
#include <altera_avalon_uart.h>
#include "altera_avalon_uart_regs.h"
//#include <altera_avalon_i2c.h>
//#include "altera_avalon_i2c_regs.h"
#include "sys/alt_irq.h"
#include <math.h>
#include <io.h>
#include <unistd.h>


#define interval 20000//micro s
#define TRUE 1
#define FALSE 0
//REGISTER DEFINITION START
#define SENSORS_GRAVITY_EARTH             (9.80665F)              /**< Earth's gravity in m/s^2 */
#define SENSORS_GRAVITY_MOON              (1.6F)                  /**< The moon's gravity in m/s^2 */
#define SENSORS_GRAVITY_SUN               (275.0F)                /**< The sun's gravity in m/s^2 */
#define SENSORS_GRAVITY_STANDARD          (SENSORS_GRAVITY_EARTH)
#define SENSORS_MAGFIELD_EARTH_MAX        (60.0F)                 /**< Maximum magnetic field on Earth's surface */
#define SENSORS_MAGFIELD_EARTH_MIN        (30.0F)                 /**< Minimum magnetic field on Earth's surface */
#define SENSORS_PRESSURE_SEALEVELHPA      (1013.25F)              /**< Average sea level pressure is 1013.25 hPa */
#define SENSORS_DPS_TO_RADS               (0.017453293F)          /**< Degrees/s to rad/s multiplier */
#define SENSORS_GAUSS_TO_MICROTESLA       (100)                   /**< Gauss to micro-Tesla multiplier */

#define BNO055_ADDR 0x28
#define STOP_BIT 0x100


//Operation mode setting
#define OPR_MODE_ADDR 0x3d
#define CONFIG_MODE 0x00
#define GYRONLY_MODE 0x03
#define ACC_GYRO_MODE 0x05
#define AMG_MODE 0x07
#define IMU_MODE 0x0c

//Power mode setting
#define PWR_MODE_ADDR 0x3e
#define NORMAL_MODE 0x00
#define LOW_MODE 0x01
#define SUSPEND_MODE 0x02

//Caliblation
#define CALIB_STAT_ADDR 0x35
#define RST_SYS_ADDR 0x3f


//Status registers
#define CHIP_ID 0x00
#define SYS_CLK_STAT 0x38
#define PAGE_ID 0x07
#define PAGE_0 0x00
#define PAGE_1 0x01

//加速度アドレス
#define ACC_X_LSB 0x08
#define ACC_X_MSB 0x09
#define ACC_Y_LSB 0x0a
#define ACC_Y_MSB 0x0b
#define ACC_Z_LSB 0x0c
#define ACC_Z_MSB 0x0d
//角速度アドレス
#define GYR_X_LSB 0x14
#define GYR_X_MSB 0x15
#define GYR_Y_LSB 0x16
#define GYR_Y_MSB 0x17
#define GYR_Z_LSB 0x18
#define GYR_Z_MSB 0x19
//クォータニオン(姿勢）
#define QUA_W_LSB 0x20
#define QUA_W_MSB 0x21
#define QUA_X_LSB 0x22
#define QUA_X_MSB 0x23
#define QUA_Y_LSB 0x24
#define QUA_Y_MSB 0x25
#define QUA_Z_LSB 0x26
#define QUA_Z_MSB 0x27
//I2C IP core
#define ENABLE 0x3//BUS_SPEED:高速(400kbps),ENABLE:有効
#define DISABLE 0x0

//UART
#define UART_START 0xaa
#define UART_READ 0x01
#define UART_WRITE 0x00
#define RES_SUCCESS 0xbb
#define RES_FAIL 0xee
#define WR_STATUS 0xee
#define SYS_TRG_ADDR 0x3f

typedef uint8_t u8;//符号なし8bit整数

u8 BNO055_READ(u8 adr,u8 length){
	int i;
	u8 rd_data;
	int flg=0;
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,UART_START);//start byte
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,UART_READ);//read 0x01
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,adr);//address
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,length);//length

	for(i=0;i<1000;i++){
				rd_data=IORD_ALTERA_AVALON_UART_RXDATA(UART2_BASE);
				if(flg==0){
					if(rd_data==RES_SUCCESS){
						flg++;
					}else if(rd_data==RES_FAIL){
						flg--;
					}
				}else if(flg==1){
					if(rd_data==0x01){
						flg++;
					}
				}else if(flg==2&&rd_data!=0x01){
					return rd_data;
				}else if(flg==-1){
					if(rd_data!=RES_FAIL){
					printf("Error:%d\n",rd_data);
					return -1;
				}
			}
	}
	return -1;
}




u8 BNO055_WRITE(u8 adr,u8 data,u8 length){
	int i;
	int flg;
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,UART_START);//start byte
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,UART_WRITE);//write 0x00
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,adr);//register address
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,length);//length
	IOWR_ALTERA_AVALON_UART_TXDATA(UART2_BASE,data);//data

	u8 status[2]={0,0};

	for(i=0;i<1000;i++){
				status[0]=IORD_ALTERA_AVALON_UART_RXDATA(UART2_BASE);
				usleep(100);
				status[1]=IORD_ALTERA_AVALON_UART_RXDATA(UART2_BASE);
				if(status[0]!=0xee){
						if(status[1]==0x01){
							printf("Write Success\n");
							break;
						}else{
							printf("Wr_status2=%d\n",status[1]);
							break;
						}
					}
				}
}

void IMU_WRITE(u8 adr,u8 data){
	BNO055_WRITE(adr,data,1);
}
u8 IMU_READ(u8 adr){
	u8 rd_data=BNO055_READ(adr,1);
	return rd_data;
}

int IMU_init(void){//IMU,I2Cの初期化関数
	u8 chip_id=0;
	IMU_WRITE(PAGE_ID,0);
	IMU_WRITE(OPR_MODE_ADDR,CONFIG_MODE);//CONFIG_MODE
	usleep(1000);

	IMU_WRITE(PWR_MODE_ADDR,NORMAL_MODE);
	usleep(1000);
	IMU_WRITE(SYS_TRG_ADDR,0xe0);
	usleep(1000);

	IMU_WRITE(OPR_MODE_ADDR,ACC_GYRO_MODE);//IMU_MODE
	usleep(1000);

	printf("CHIP_ID=%04d\n",IMU_READ(CHIP_ID));

	return 0;
}



#endif /* IMU_UART_H_ */
