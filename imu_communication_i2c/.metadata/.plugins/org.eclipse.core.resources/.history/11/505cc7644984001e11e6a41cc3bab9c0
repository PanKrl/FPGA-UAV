//IMU_communication

#include <stdio.h>
#include <stdlib.h>
#include "system.h"
#include <string.h>
#include "altera_avalon_pio_regs.h"
#include <altera_avalon_uart.h>
#include "altera_avalon_uart_regs.h"
#include <altera_avalon_i2c.h>
#include "altera_avalon_i2c_regs.h"
#include "sys/alt_irq.h"
#include <math.h>
#include <io.h>
#include <unistd.h>


#define interval 20000
#define TRUE 1
#define FALSE 0

#define BNO055_ADDR 0x28
#define STOP_BIT 0x100
//Power mode setting
#define PWR_MODE_ADDR 0x3e
#define NORMAL_MODE 0x00
#define LOW_MODE 0x01
#define SUSPEND_MODE 0x02

//Operation mode setting
#define OPR_MODE_ADDR 0x3d
#define CONFIG_MODE 0x00
#define GYRONLY_MODE 0x03
#define ACC_GYRO_MODE 0x05
#define AMG_MODE 0x07
#define IMU_MODE 0x0c

//Status registers
#define CHIP_ID 0x00
#define SYS_CLK_STAT 0x38


//加速度アドレス
#define ACC_DATA_X_LSB 0x08
#define ACC_DATA_X_MSB 0x09
#define ACC_DATA_Y_LSB 0x0a
#define ACC_DATA_Y_MSB 0x0b
#define ACC_DATA_Z_LSB 0x0c
#define ACC_DATA_Z_MSB 0x0d
//角速度アドレス
#define GYR_DATA_X_LSB 0x14
#define GYR_DATA_X_MSB 0x15
#define GYR_DATA_Y_LSB 0x16
#define GYR_DATA_Y_MSB 0x17
#define GYR_DATA_Z_LSB 0x18
#define GYR_DATA_Z_MSB 0x19

//クォータニオン(姿勢）
#define QUA_DATA_W_LSB 0x20
#define QUA_DATA_W_MSB 0x21
#define QUA_DATA_X_LSB 0x22
#define QUA_DATA_X_MSB 0x23
#define QUA_DATA_Y_LSB 0x24
#define QUA_DATA_Y_MSB 0x25
#define QUA_DATA_Z_LSB 0x26
#define QUA_DATA_Z_MSB 0x27

#define ENABLE 0x3//BUS_SPEED:高速(400kbps),ENABLE:有効
#define DISABLE 0x0

unsigned short quat_w,quat_x,quat_y,quat_z;


short TFR_CMD(short STA,short STO,short AD,short RW_D){//コマンドの生成
	short cmd=(STA<<9|STO<<8|AD<<1|RW_D);
	return cmd;
}
void IMU_WRITE(short adr,short data){//IMUの書き込み関数
	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,TFR_CMD(0x1,0x0,adr,0x0));
	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,adr);
	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,STOP_BIT|data);
}

unsigned short IMU_READ(short adr){//IMUの読み取り関数
	volatile int i;

	unsigned short rd_data=0xff;

	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,TFR_CMD(0x1,0x0,BNO055_ADDR,0x0));
	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,(STOP_BIT|adr));
	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,TFR_CMD(0x1,0x0,BNO055_ADDR,0x1));
	IOWR_ALT_AVALON_I2C_TFR_CMD(I2C_BASE,STOP_BIT);

	for(i=0;i<10000;i++){
		rd_data=IORD_ALT_AVALON_I2C_RX_DATA(I2C_BASE);//read rxdata
		return rd_data;
	}
	}

void IMU_init(void){//IMU,I2Cの初期化関数
	IOWR_ALT_AVALON_I2C_CTRL(I2C_BASE,DISABLE);//i2c_disable

	IOWR_ALT_AVALON_I2C_ISER(I2C_BASE,0x0);//ISERのコンフィグレーション
	IOWR_ALT_AVALON_I2C_SCL_LOW(I2C_BASE,0x1);//SCL_LOWのコンフィグレーション
	IOWR_ALT_AVALON_I2C_SCL_HIGH(I2C_BASE,0x1);//SCL_HIGHのコンフィグレーション
	IOWR_ALT_AVALON_I2C_SDA_HOLD(I2C_BASE,0x1);//SDA_HOLDのコンフィグレーション

	IOWR_ALT_AVALON_I2C_CTRL(I2C_BASE,ENABLE);//i2c_enable

	if(IORD_ALT_AVALON_I2C_CTRL(I2C_BASE)==ENABLE){
	printf("I2C Start\n");
	}
	IMU_WRITE(PWR_MODE_ADDR,NORMAL_MODE);//POWER:NORMAL_MODE
	IMU_WRITE(OPR_MODE_ADDR,CONFIG_MODE);//CONFIGURATION_MODE
	IMU_WRITE(OPR_MODE_ADDR,IMU_MODE);//IMU_MODE

	short chip_status=IMU_READ(CHIP_ID);
	printf("%04d\n",chip_status);//0xa0＝160になれば正常



}

int main(){
    IMU_init();

	while(1){
		quat_w=IMU_READ(QUA_DATA_W_LSB)|(IMU_READ(QUA_DATA_W_MSB)<<8);
		quat_x=IMU_READ(QUA_DATA_X_LSB)|(IMU_READ(QUA_DATA_X_MSB)<<8);
		quat_y=IMU_READ(QUA_DATA_Y_LSB)|(IMU_READ(QUA_DATA_Y_MSB)<<8);
		quat_z=IMU_READ(QUA_DATA_Z_LSB)|(IMU_READ(QUA_DATA_Z_MSB)<<8);

        printf("quat_w=%04d ",quat_w);
        printf("quat_x=%04d ",quat_x);
        printf("quat_y=%04d ",quat_y);
        printf("quat_z=%04d ",quat_z);
        printf("\n");

	}

return 0;

}

