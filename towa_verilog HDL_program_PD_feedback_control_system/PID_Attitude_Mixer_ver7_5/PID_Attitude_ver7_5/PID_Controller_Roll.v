// -------------------------------------------------------------
// 
// File Name: D:\fukuda\B4\HDLCoder\2023_12_15\PID_Attitude\PID_Attitude_Mixer_ver7_5\PID_Attitude_ver7_5\PID_Controller_Roll.v
// Created: 2024-02-07 16:17:48
// 
// Generated by MATLAB 9.12 and HDL Coder 3.20
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PID_Controller_Roll
// Source Path: PID_Attitude_ver7_5/PID_Controller_Roll
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PID_Controller_Roll
          (clk,
           reset_n,
           x_gyro,
           Trigger,
           F_Roll);


  input   clk;
  input   reset_n;
  input   signed [15:0] x_gyro;  // int16
  input   Trigger;  // ufix1
  output  [31:0] F_Roll;  // single


  wire Trigger_delay_ctrl_const_out;
  reg  Trigger_delay_ctrl_delay_out;
  wire Trigger_delay_Initial_Val_out;  // ufix1
  reg  Trigger_delay_out;  // ufix1
  wire Trigger_delayed;  // ufix1
  wire Trigger_delayed_inverted;  // ufix1
  wire Trigger_emulated;  // ufix1
  wire [31:0] Target_Angle_out1;  // ufix32
  wire [31:0] CtrlCycl_out1;  // ufix32
  wire signed [31:0] Gain_out1;  // sfix32_En20
  wire [31:0] x_angle;  // ufix32
  wire [31:0] x_angle_1;  // ufix32
  wire [31:0] Product_out1;  // ufix32
  wire [31:0] error;  // ufix32
  wire pw2_sign_const;  // ufix1
  wire signed [8:0] pw2_shift_const;  // sfix9
  wire [31:0] kconst;  // ufix32
  wire [31:0] error_1;  // ufix32
  reg [31:0] Unit_Delay_out1;  // ufix32
  wire [31:0] K_p_out1;  // ufix32
  wire [31:0] kconst_1;  // ufix32
  wire [31:0] Add2_out1;  // ufix32
  wire [31:0] Freq_out1;  // ufix32
  wire [31:0] K_d_out1;  // ufix32
  wire [31:0] Sum_out1;  // ufix32
  reg [31:0] Memory_out1;  // ufix32
  wire [31:0] Memory_out1_1;  // ufix32
  reg [31:0] Memory_out1_last_value;  // ufix32


  assign Trigger_delay_ctrl_const_out = 1'b1;



  always @(posedge clk or posedge reset_n)
    begin : Trigger_delay_ctrl_delay_process
      if (reset_n == 1'b1) begin
        Trigger_delay_ctrl_delay_out <= 1'b0;
      end
      else begin
        Trigger_delay_ctrl_delay_out <= Trigger_delay_ctrl_const_out;
      end
    end



  assign Trigger_delay_Initial_Val_out = 1'b1;



  always @(posedge clk or posedge reset_n)
    begin : Trigger_delay_process
      if (reset_n == 1'b1) begin
        Trigger_delay_out <= 1'b0;
      end
      else begin
        Trigger_delay_out <= Trigger;
      end
    end



  assign Trigger_delayed = (Trigger_delay_ctrl_delay_out == 1'b0 ? Trigger_delay_Initial_Val_out :
              Trigger_delay_out);



  assign Trigger_delayed_inverted =  ~ Trigger_delayed;



  assign Trigger_emulated = Trigger_delayed_inverted & Trigger;



  assign Target_Angle_out1 = 32'h00000000;



  assign CtrlCycl_out1 = 32'h3c4ccccd;



  assign Gain_out1 = 16'sb0100011101111101 * x_gyro;



  nfp_convert_sfix_32_En20_to_single u_PID_Attitude_ver7_5_PID_Controller_Roll_nfp_convert_sfix_32_En20_to_single (.nfp_in(Gain_out1),  // sfix32_En20
                                                                                                                   .nfp_out(x_angle)  // single
                                                                                                                   );

  assign x_angle_1 = x_angle;

  nfp_mul_single u_nfp_mul_comp (.nfp_in1(CtrlCycl_out1),  // single
                                 .nfp_in2(x_angle_1),  // single
                                 .nfp_out(Product_out1)  // single
                                 );

  nfp_sub_single u_nfp_sub_comp (.nfp_in1(Target_Angle_out1),  // single
                                 .nfp_in2(Product_out1),  // single
                                 .nfp_out(error)  // single
                                 );

  assign pw2_sign_const = 1'b0;



  assign pw2_shift_const = 9'sb111111111;



  assign kconst = 32'h42a00000;



  assign error_1 = error;

  always @(posedge clk or posedge reset_n)
    begin : Unit_Delay_process
      if (reset_n == 1'b1) begin
        Unit_Delay_out1 <= 32'h00000000;
      end
      else begin
        if (Trigger_emulated) begin
          Unit_Delay_out1 <= error_1;
        end
      end
    end



  nfp_gain_pow2_single u_nfp_gain_pow2_single (.nfp_in1(error),  // single
                                               .nfp_in2(pw2_sign_const),  // ufix1
                                               .nfp_in3(pw2_shift_const),  // sfix9
                                               .nfp_out(K_p_out1)  // single
                                               );

  assign kconst_1 = 32'h3f19999a;



  nfp_sub_single u_nfp_sub_comp_1 (.nfp_in1(error),  // single
                                   .nfp_in2(Unit_Delay_out1),  // single
                                   .nfp_out(Add2_out1)  // single
                                   );

  nfp_mul_single u_nfp_mul_comp_1 (.nfp_in1(kconst),  // single
                                   .nfp_in2(Add2_out1),  // single
                                   .nfp_out(Freq_out1)  // single
                                   );

  nfp_mul_single u_nfp_mul_comp_2 (.nfp_in1(kconst_1),  // single
                                   .nfp_in2(Freq_out1),  // single
                                   .nfp_out(K_d_out1)  // single
                                   );

  nfp_add_single u_nfp_add_comp (.nfp_in1(K_p_out1),  // single
                                 .nfp_in2(K_d_out1),  // single
                                 .nfp_out(Sum_out1)  // single
                                 );

  always @(posedge clk or posedge reset_n)
    begin : Memory_process
      if (reset_n == 1'b1) begin
        Memory_out1 <= 32'h00000000;
      end
      else begin
        if (Trigger_emulated) begin
          Memory_out1 <= Sum_out1;
        end
      end
    end



  always @(posedge clk or posedge reset_n)
    begin : out0_bypass_process
      if (reset_n == 1'b1) begin
        Memory_out1_last_value <= 32'h00000000;
      end
      else begin
        if (Trigger_emulated) begin
          Memory_out1_last_value <= Memory_out1_1;
        end
      end
    end



  assign Memory_out1_1 = (Trigger_emulated == 1'b0 ? Memory_out1_last_value :
              Memory_out1);



  assign F_Roll = Memory_out1_1;

endmodule  // PID_Controller_Roll

