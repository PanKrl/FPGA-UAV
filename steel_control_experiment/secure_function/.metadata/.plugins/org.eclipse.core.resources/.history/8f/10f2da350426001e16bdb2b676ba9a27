#include <stdio.h>
#include <stdlib.h>
#include "sys/alt_stdio.h"
#include "system.h"
#include <string.h>
#include "altera_avalon_pio_regs.h"
#include "altera_avalon_uart_regs.h"
#include "sys/alt_irq.h"
#include <math.h>

#define PWM2RAD 0.002 //  Based upon 5RAD for full stick movement, you take this times the RAD to get the PWM conversion factor

// Receiver variables
#define TIMEOUT 25000
#define MINDELTA 200
#define LEVELOFF 100
#define MAX_NB_CHANNEL 10
#define SBUS_SYNCBYTE 0x0F // some sites say 0xF0

#define SERIAL_SBUS Serial3
static byte sbus[25] = {0};

class FUTABA_SBUS
{
  public:

    // 16 analog, 2 digital channels
    unsigned int rcChannel[18] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};
    unsigned int sbusIndex = 0;

#if defined (UseSBUSRSSIReader)
    unsigned short sbusFailSafeCount = 0;
    unsigned long sbusFrameCount = 0;
    unsigned short sbusRate = 0;
#endif

    // SBUS信号のデコード

    void readSBUS() {
      while (1) {

        int val = IORD_ALTERA_AVALON_UART_RXDATA(UART1_BASE);
        //Serial.println(val);
        if (sbusIndex == 0 && val != SBUS_SYNCBYTE) {
          continue;
        }

        sbus[sbusIndex] = val;
        sbusIndex++;
        if (sbusIndex == 25) {
          //Serial.println("OK");
          //Serial.println(sbus[24]);
          sbusIndex = 0;
          // check stop bit before updating buffers
          if (sbus[24] != 0x0) {

            // 1Chにつき11bitなので、ずらしながら格納。
            // 368〜1680の数値の出処は不明

            rcChannel[0]  = ((sbus[1]     | sbus[2] << 8)  & 0x07FF);
            rcChannel[1]  = ((sbus[2] >> 3  | sbus[3] << 5)  & 0x07FF);
            rcChannel[2] = ((sbus[3] >> 6  | sbus[4] << 2   | sbus[5] << 10) & 0x07FF);
            rcChannel[3]  = ((sbus[5] >> 1  | sbus[6] << 7)  & 0x07FF);
            rcChannel[4]   = ((sbus[6] >> 4  | sbus[7] << 4)  & 0x07FF);
            rcChannel[5]   = ((sbus[7] >> 7  | sbus[8] << 1   | sbus[9] << 9) & 0x07FF);
            rcChannel[6]   = ((sbus[9] >> 2  | sbus[10] << 6) & 0x07FF);
            rcChannel[7]   = ((sbus[10] >> 5 | sbus[11] << 3) & 0x07FF);
            rcChannel[8]   = ((sbus[12]    | sbus[13] << 8) & 0x07FF);
            rcChannel[9]   = ((sbus[13] >> 3 | sbus[14] << 5) & 0x07FF);
            rcChannel[10]   = ((sbus[14] >> 6 | sbus[15] << 2 | sbus[16] << 10) & 0x07FF);
            rcChannel[11]   = ((sbus[16] >> 1 | sbus[17] << 7) & 0x07FF);
            rcChannel[12]   = ((sbus[17] >> 4  | sbus[18] << 4)  & 0x07FF);
            rcChannel[13]   = ((sbus[18] >> 7  | sbus[19] << 1   | sbus[20] << 9) & 0x07FF);
            rcChannel[14]   = ((sbus[20] >> 2  | sbus[21] << 6) & 0x07FF);
            rcChannel[15]   = ((sbus[21] >> 5 | sbus[22] << 3) & 0x07FF);

#ifdef UseSBUSRSSIReader
            if (sbusRate == 0) {
              sbusFrameCount++;
            }
            if (((sbus[23] >> 3) & 0x0001)) {
              if ((sbusRate > 0) && (sbusFailSafeCount < sbusRate)) {
                sbusFailSafeCount++;
              }
            } else if (sbusFailSafeCount > 0) {
              sbusFailSafeCount--;
            }
#endif
          }
        }
      }
    }

    int16_t getData(uint8_t ch) {
      return rcChannel[ch];
    }

};
